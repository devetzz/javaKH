5 박강호

파일 로드(FileInputStream , Scanner)
파일가져오기 > 첫라인 따로 저장 > 
무한반복을 통해 파일을 읽어와서 ArrayList에 저장{탈출방안 > 1라인씩 가져오기 > 가져온 라인을 split을 통해 쪼개서 tokens[]에 저장 > 쪼갠 값 및 연산결과 객체에 저장 > 객체를 ArrayList에 저장} > 무한반복 밖에서 close

파일 저장(FileOutputStream, PrintStream)
파일 내용 모두 지우고 ArrayList의 내용 저장 > 저장해둔 첫라인(컬럼명) 가져오기 > for문통한 라인별 쓰기 > close



Java
2025.04.15 (17일차)
equals : 객체의 주소를 비교
String에서 오버라이딩해서 문자열을 비교하는 메소드처럼 보일수 있다.

toString : 오버라이딩 하지않으면 객체의 주소 반환

동기화
 -  멀티스레드 환경에서 여러 스레드가 공유 자원에 접근할때 발생할 수 있는 문제를 방지하기 위해 사용되는 기술
 - 데이터의 일관성을 보장하고, 동시에 여러 스레드가 데이터에 접근하거나 수정하지 못하도록 제어


CRUD
필터링
매핑
리듀서
정렬

예외처리
 - Error : 너무 심각해서 할 수 있는 방법이 없음 -> 통과 (ex. 인터넷 연결 이슈)
 - Runtime Exception(Unchecked Exception) : 프로그래밍 버그이므로 스스로 고쳐야함 -> 통과
 - Checked Exception : Error나 Runtime Exception이 아닌 예외 > 반드시 처리해야함(컴파일러가 체크, 빨간줄 발생) -> 검사

실행중에 발생하는 Runtime Exception에 대해 개발자가 처리를 해줘야함.

try{
	예외가 발생할 수 있는 코드
}catch (예외클래스 변수) {
	예외를 처리하는 코드
}finally{
	try블록이 끝나면 무조건 실행하는 코드
}

catch는 여러개 가능, finally는 생략 가능
try 영역을 좁게 잡는게 핵심











2025.04.11 (16일차)

내부 클래스
 - 외부 클래스의 인스턴스 변수와 메소드를 전부 사용할 수 있다.

지역 클래스
 - 메소드 안에 정의되는 클래스

익명 클래스 (자바 스크립트, 리액트에 많이 사용)
 - (자바)다형성을 구현하기 위한 방법
 - 자식클래스를 만들지 않고 다형성을 구현할 수 있다.



변수 배열 클래스 클래스배열 컬랙션프레임워크

반복문

제어문

모듈화

인터페이스, 상속


⭐⭐⭐참조변수는 값이 아닌 주소를 기억한다.

스택에는 함수저장, 프로그램이 끝나면 사라진다.
힙에는 

String name = "상수";
클래스가 로드될때 1번 생성한다.
String name1 = new String("홍길동");
new 할떄 마다 새로 생성한다.


this 와 super는 첫쨰줄에 쓴다.









2025.04.10 (15일차)
추상 클래스 : 미완성된 메소드를 가지고 있기때문에 추상클래스로는 객체를 생성할 수 없다.
주로 부모 계층에서 추상적인 개념을 나타내기 위한 용도로 사용
추상클래스 = 상속 + 오버라이딩
abstract class

인터페이스 >>> 추상클래스
인터페이스는 다중 상속이 가능하다.
다중상속의 문제 : 모호성
인터페이스는 모호성을 없앤다.

인터페이스 구성 (오버라이딩, 다형성 구현)
 - 추상 메소드
 - 상수
 - 정적메소드, 디폴트 메소드, private 메소드
각 클래스간의 상호 작용을 기술하는 일종의 규격


implements

타입이 같으면 extends
타입이 다르면 implements

인터페이스에 구현된 추상 메소드는 해당 인터페이스를 사용하는 클래스들에서 무조건 구현해야한다.

디폴트 메소드는 인터페이스에서 제공하며, 인터페이스를 사용하는 클래스들이 별도 오버라이딩을 구현하지 않았을때 사용하는 메소드이다.

인터페이스에서 정의된 변수는 자동적으로 public static final이 되어 상수가 된다.


Comparable 인터페이스
데이터 클래스에 사용
compareTo() 메소드를 정의하여 두 객체를 비교하는 방법을 지정할 수 있다.
(크냐: 양수, 작냐: 음수, 같으냐: 0)

Collections.sort()
Collections.reverseOrder();

테스트:
클리어
비교
정렬

내일 테스트 예정: 
데이터클래스 하나로 12기능 만들기



2025.04.09 (14일차)
메인에서는 정적 멤버변수, 함수만 사용한다.
메인이 정적 멤버 함수이기 때문에 인스턴스가 생성되기 전에는
어차피 인스턴스 멤버변수,함수는 사용할 수 없다.

this로 쓰면 상속된거 안되면 상속안된거

상속 가능 (정의안해도 사용 가능)
 - 멤버변수
 - 멤버함수
 - 내부클래스
상속 불가
 - 생성자
 - private

상속을 받으면 자식은 부모 객체를 만들어줘야된다.
안만들면 디생을 컴파일러가 만들어버린다.
메생이 있으면 자식은 무조건 메생에 super를 정의해야 한다.

생성자 호출 순서
부모 생성자 -> 자식 생성자

upCasting
부모가 자식 영역의 부모 객체를 호출
downCasting


upCasting은 무조건 된다.
downCasting은 
upCasting된 상황에서만 downCasting 가능

instanceof > 부모가 자식 타입을 가지고 있는지 확인
if(부모인스턴스 instanceof 자식타입) > true or false


오버라이딩 > 다형성 구현을 위해 사용 (다형성 구현이 되는지 안되는지 체크 가능)
부모 클래스 하나로 자식 클래스들을 관리


정적멤버함수는 클래스가 로드될때 이미 구현이 된 상태이기 때문에 다형성 구현이 안된다.



테스트 :
페이징 추가해라






2025.04.08 (13일차)
상속 : 부모꺼는 자식꺼
부모 객체의 구성을 자식도 가지고 있다.
부모는 모든 자식의 번지를 받을 수 있다.

super() => 부모꺼를 가져오고 싶을때 사용

생성자는 상속할 수 없다.
super를 사용해서 만든다.

생성자의 첫줄에서만 super로 부모를 부를수 있다.

private 

오버라이딩 : 부모꺼의 원형을 고쳐쓰고 싶을때 사용


FileOutputStream(String name, boolean append)
append(덧붙이다, 추가하다) 를 안쓰면 기존내용을 전부 날리고 저장한다.(기본적으로 false)


객체 직렬화 (Serializable) : 객체가 가진 데이터를 순차적인 데이터로 변환하는 것
역직렬화 (deserializable) : 직렬화된 데이터를 읽어서 객체로 복구하는 것


테스트 : 
1. 정적 블럭을 만들어서 로드를 시켜라.(단, main 앞에 복잡한 구조는 메소드화 처리)
2. 저장 기능을 활성화 시켜라. (꼭 주의할 내용, 숙지)
3. 삭제 기능을 활성화 시켜라.
4. 추가 기능을 활성화 시켜라.
5. 수정 기능을 활성화 시켜라.








2025.04.07 (12일차)
FileReader
FileInputStream

read() : 입력 스트림으로부터 단일 바이트를 읽고 읽은 바이트를 0~255사이 정수로 반환
	더 이상 읽을 데이터가 없는 경우 -1 을 반환

무한 반복을 통해 한 라인 씩 가져와서 => String tokens => 형변환시켜서 => StudentData 객체 => ArrayList

⭐⭐⭐첫라인 버리기 
=> 무한 반복 > 1라인 씩 가져오기 > 가져온거 split으로 컬럼 별로 쪼개서 형변환 시킨 뒤 tokens 배열에 저장
=> 나머지 변수 연산 후 객체 저장 => ArrayList

테스트 : 
파일 만들어서 가져올것
1. 임직원 로드
2. 임직원 입력
3. 임직원 출력
4. 급여 최대값
5. 급여 최소값
6. 임직원 검색
7. 종료

예외처리+패턴검색
패턴검색 메소드화
파일 가져오기

//변수선언
//반복
	//메뉴보여주기
	//메뉴선택
	switch(){
	//파일 로드
	//첫라인 버리기
	//무한 반복을 통해 한라인씩 가져와서 => String[] Tokens 에 split을 통해  라인별로 저장 => 인스턴스 호출해서  생성자 호출 => ArrayList에 저장
	//입력 (패턴검색 메소드화)
	//출력 (향상된 포문 사용)
	// 최대값
	// 최소값
	// 검색 (향상된 포문 사용)
	// 종료
	}


2025.04.04 (11일차)

입력, 로드 (DB > class > ArrayList)
연산 (ArrayList > 연산)
출력, 저장 (class > ArrayList > DB)

객체를 메소드에 전달하면 값이 아닌 주소가 전달된다.

정적 변수, 메소드 > class명. 으로 사용
정적 메소드에서는 인스턴스 멤버를 사용하면 안됨


상속 못받는것 : 생성자

테스트 ~5시
ArrayList에 저장
// 번호, 제목, 평점
1. 책 등록
2. 책 검색
3. 책 출력
4. 책 삭제
5. 수정
6. 종료


과제 : 
강의   ~상속


2025.04.03 (10일차)

레퍼런스 타입은 모두 주소를 전달한다.

"문자열"은 == 이 아닌 equals 메서드로 비교


테스트: ArrayTotalTest
사이즈 5인 배열속에서 랜덤 값 이용

메뉴 선택
1. 배열 입력(랜덤100~999)
2. 배열 출력
3. 최대값 : max
4. 최소값 : min
5. 내림차순정렬
6. 오름차순정렬
7. 배열 검색 : 입력한 값이 있으면 있다, 없으면 없다 출력
8. 종료

과제:
여러분의 주제를 가지고 
 - 배열 >> ArrayList 로 변경
 - 삭제기능 추가

// 사원 테이블 > 이름, 부서, 급여, 등급, 보너스 포인트(double), 총급여
1. 입력
2. 출력
3. 계산
4. 검색
5. 삭제
6. 종료

2025.04.02 (9일차)
생성자 함수
Default 생성자
 - 리턴 값이 없다.
 - 클래스와 동일한 이름으로 만든다.(권장)
public 클래스명() { }


생성자 오버로딩 (함수 오버로딩)
함수명일 같을 때
매개변수 갯수나 타입이 다르면 같은 이름을 사용할 수 있다.

오버로딩 조건이 아닌 것
 - 접근제어자
 - 리턴값
 - 예외처리

오버로딩
 - 같은 클래스 내에서 메서드 이름은 같지만, 매개변수가 다른 여러 메서드를 정의하는 것
오버라이딩
 - 부모 클래스에서 정의된 메서드를 자식 클래스에서 재정의 하는것
 > 함수명, 매개변수 갯수, 타입, 접근제어자, 리턴값, 예외처리 모두 같아야함. (접근제어자, 예외처리는 범위가 더크면 된다.)
 > 접근제어자 영역이 커져야함.

상속 시 멤버 변수, 멤버 함수는 상속되지만 생성자는 상속되지 않음.
생성자 호출을 위해 super를 사용


과제 : 
패턴 검색 만들어오기





2025.04.01 (8일차)

실행 클래스 (메인 포함된)
데이터 클래스

static
O > 코드 영역에
X > 힙 영역에


클래스 주제를 정해서 만든다
메인을 만든다
입출력 대화식 반복

멤버 변수는 직접 접근하지 않는다.
함수를 통해 접근해라. (get, set)

캡슐화의 장점
1. 멤버 변수와 멤버 함수를 하나로 묶는다.
2. 외부로부터의 접근을 막아 내부 정보를 은닉한다.


과제 : 
하나의 주제를 정해서 어제 과제의 클래스화



2025.03.31 (7일차)

가상 메모리
1. method 영역
2. stack 영역
3. hip 영역

배열의 장점
1. 변수 하나로 사용
2. 반복문 사용 용이
배열의 단점
3. 확장/축소가 안된다.

배열의 단점을 개선한 클래스 > ArrayList


과제
1. 다음은 학생 성적 입력 프로그램을 작성한다. (10명정도 입력)
1.1 구조는 배열을 이용한다. (ArrayList 가능)
1.2 학생정보는 이름, 나이, 성별, 국어, 영어, 총점, 평균, 등급별로 저장되어 있어야한다.
String[] name = new String[10];
int[] age = new int[10];
char[] gender = new char[10];
int[] kor = new int[10];
int[] eng = new int[10];
int[] total = new int[10];
double[] avr = new double[10];
String[] grade = new String[10];  A+,A, B+,B,C+,C,D+,D,F
1.3 입력은 이름, 나이, 성별, 국어 영어 만 입력한다. 총점, 평균, 등급은 계산해서 저장한다.
1.4 메뉴를 만든다.(학생입력, 학생출력, 종료, 학생계산, 
학생검색(선택) :이름  if(imsiName.equals(name[i])){  정보를 출력하면된다.}


1. 학생입력
2. 학생출력
3. 학생계산
4. 학생검색
5. 종료




2025.03.28 (6일차)

문자열과 정수,실수를 덧셈 계산하면 문자열로 변환하여 계산한다. "100"+200 => 100200
문자열과 정수,실수를 뺄셈 계산하면 계산하지 않는다.

메모리는 1번지당 1바이트

포인터 변수 4바이트인 이유 => 2^32-1 => 번지수 이기 때문에 2^30*2^2 => 2^30 = 1GB => 1GB*4 => 4GB

패턴 검색
Pattern.maches()

정규표현식
* => 0개이상
+ => 1개 이상
{2,3} => 2~3개

1. 라이브러리 함수가 있는가
2. 상수가 있는가

switch문을 쓰는 이유
if else 

실습 : 
문제 1) 별표 찍기 1~5단계 (1개 선택)
문제 2) 4단계패턴
 - 성명, 국, 영, 수 입력받아서 패턴 검색(잘못되면 다시 입력 받을 것)
 - 총점 : 국 영 수 합산
 - 평균 : 총점 / 과목수 (소숫점 2자리까지 실수값으로)
 - 등급 : A B C D F 등급으로 구한다. (switch, if~else if 2가지로 작성)
 - 출력 : 포맷에 알맞게(간지나게)
 - 조건 : 대화식 무한반복


2025.03.27 (5일차)

과제:
자바연습문제
2장
1~13
15~19

코딩
5, 7번

4단계







2025.03.26 (4일차)
do-while 사용법

참조변수의 Default값은 null

기본형 변수에는 값이 직접 저장된다.
(int, double, ...)
참조형 변수에는 객체의 번지가 저장된다.
(배열,클래스,인터페이스)

과제 : 
빛이 n일동안 이동한거리 입력받아서 출력
형변환 실습
33페이지 중간 점검

1. 8비트 124 => (    )(b) => (    )(o) => (    )(x)
2. 8비트 -24 메모리저장 되었을때 표현 (           )(b)
3. 45.125F 메모리저장 되었을때 표현 32비트 구조 (           )(b)
4. 연산자 우선 순위 표



2025.03.25 (3일차)

과제: 수업시간 완료
20, 10을입력을 받아서 사칙연산 계산하여 출력하는 프로그램
1. 상수
2. 입력받아서
3. 반복문


513L : long형 리터럴 상수

1의 보수를 쓰면 가산기를 한번더 사용하기 때문에 "2의 보수"를 사용
(속도 우위)

모든 연산은 덧셈으로 한다

뺄셈 : 뺄 숫자를 2의 보수 시켜서 덧셈
곱셈 : 왼쪽으로 비트 이동 << ? 
나눗셈 : 오른쪽으로 비트 이동 >> ?


실수는 정확한 값을 알기 어렵다.
실수를 쓰는 순간 속도는 느리다.
최대한 근사치라도 구하기 위해 float보단 double을 사용한다.


과제:

자바 연습문제 워드파일
8페이지 3번 
사용자로부터 두 개의 정수를 받아서......
4단계로 
1. 출력
2. 입력받아서 출력
3. 반복해서 입출력
4. 대화식 무한반복


진법 변환
정규식 표현방법(정수, 실수)





===============================================
2025.03.24 (2일차)

자바는 중립적인 언어로 컴파일을 하게되면 바이트코드로 만든다.



컴파일
 >
바이트코드 (중간언어)
 > 
인터프리터

JVM이 바이트코드를 한줄씩 읽어서 실행


인터프리터

API : 유용한 기능을 제공하는 라이브러리의 모임

라이브러리

배열의 문제를 개선시킨 것 : 컬렉션


String name = "";		//참조변수, 첫글자 대문자, 문자열 = 4byte
int age = 3;		//4byte
double weight = 3.14;	//8byte
boolean gender = 1;	//1byte
char bloodType = 'B';	//2byte

java => UTF-16 으로 2byte 체계


입력 받기
Scanner scan = new Scanner(System.in);

scan.nextLine();

scan.close();

nextLine(); 형변환해서 사용하는 이유
외부 장치와 속도차이가 나면 반드시 완충장치를  한다. => 버퍼


for( ; ; ){
	무한으로 돌아감
}


무한 반복
bool 변수(flag값)를 통한 대화식 무한반복

1. 출력
2. 입력받아서 출력
3. 반복해서 입출력
4. 대화식 무한반복



과제:
대화식 무한 반복
정수형 실수형 문자열 문자 boolean 까지 코드 작성



코드, 결과값
화면캡처해서


스캔 경고 왜뜨는지...?
자원 누수 경고: 코드의 마지막에서 scan.close()를 호출하고 있지만, System.in을 사용하는 경우에는 닫힌 입력 스트림을 이후에 다른 작업에서 사용하려고 하면 문제가 될 수 있습니다. 예를 들어 Scanner 객체를 닫아버리면 같은 스트림을 통해 추가 입력을 받으려 할 때 예외가 발생할 수 있습니다. 







=======
6 박강호


Java

2025.04.09 (14일차)
메인에서는 정적 멤버변수, 함수만 사용한다.
메인이 정적 멤버 함수이기 때문에 인스턴스가 생성되기 전에는
어차피 인스턴스 멤버변수,함수는 사용할 수 없다.

this로 쓰면 상속된거 안되면 상속안된거


2025.04.08 (13일차)
상속 : 부모꺼는 자식꺼
부모 객체의 구성을 자식도 가지고 있다.
부모는 모든 자식의 번지를 받을 수 있다.

super() => 부모꺼를 가져오고 싶을때 사용

생성자는 상속할 수 없다.
super를 사용해서 만든다.

생성자의 첫줄에서만 super로 부모를 부를수 있다.

private 

오버라이딩 : 부모꺼의 원형을 고쳐쓰고 싶을때 사용


FileOutputStream(String name, boolean append)
append(덧붙이다, 추가하다) 를 안쓰면 기존내용을 전부 날리고 저장한다.(기본적으로 false)


객체 직렬화 (Serializable) : 객체가 가진 데이터를 순차적인 데이터로 변환하는 것
역직렬화 (deserializable) : 직렬화된 데이터를 읽어서 객체로 복구하는 것


테스트 : 
1. 정적 블럭을 만들어서 로드를 시켜라.(단, main 앞에 복잡한 구조는 메소드화 처리)
2. 저장 기능을 활성화 시켜라. (꼭 주의할 내용, 숙지)
3. 삭제 기능을 활성화 시켜라.
4. 추가 기능을 활성화 시켜라.
5. 수정 기능을 활성화 시켜라.








2025.04.07 (12일차)
FileReader
FileInputStream

read() : 입력 스트림으로부터 단일 바이트를 읽고 읽은 바이트를 0~255사이 정수로 반환
	더 이상 읽을 데이터가 없는 경우 -1 을 반환

무한 반복을 통해 한 라인 씩 가져와서 => String tokens => 형변환시켜서 => StudentData 객체 => ArrayList

⭐⭐⭐첫라인 버리기 
=> 무한 반복 > 1라인 씩 가져오기 > 가져온거 split으로 컬럼 별로 쪼개서 형변환 시킨 뒤 tokens 배열에 저장
=> 나머지 변수 연산 후 객체 저장 => ArrayList

테스트 : 
파일 만들어서 가져올것
1. 임직원 로드
2. 임직원 입력
3. 임직원 출력
4. 급여 최대값
5. 급여 최소값
6. 임직원 검색
7. 종료

예외처리+패턴검색
패턴검색 메소드화
파일 가져오기

//변수선언
//반복
	//메뉴보여주기
	//메뉴선택
	switch(){
	//파일 로드
	//첫라인 버리기
	//무한 반복을 통해 한라인씩 가져와서 => String[] Tokens 에 split을 통해  라인별로 저장 => 인스턴스 호출해서  생성자 호출 => ArrayList에 저장
	//입력 (패턴검색 메소드화)
	//출력 (향상된 포문 사용)
	// 최대값
	// 최소값
	// 검색 (향상된 포문 사용)
	// 종료
	}


2025.04.04 (11일차)

입력, 로드 (DB > class > ArrayList)
연산 (ArrayList > 연산)
출력, 저장 (class > ArrayList > DB)

객체를 메소드에 전달하면 값이 아닌 주소가 전달된다.

정적 변수, 메소드 > class명. 으로 사용
정적 메소드에서는 인스턴스 멤버를 사용하면 안됨


상속 못받는것 : 생성자

테스트 ~5시
ArrayList에 저장
// 번호, 제목, 평점
1. 책 등록
2. 책 검색
3. 책 출력
4. 책 삭제
5. 수정
6. 종료


과제 : 
강의   ~상속


2025.04.03 (10일차)

레퍼런스 타입은 모두 주소를 전달한다.

"문자열"은 == 이 아닌 equals 메서드로 비교


테스트: ArrayTotalTest
사이즈 5인 배열속에서 랜덤 값 이용

메뉴 선택
1. 배열 입력(랜덤100~999)
2. 배열 출력
3. 최대값 : max
4. 최소값 : min
5. 내림차순정렬
6. 오름차순정렬
7. 배열 검색 : 입력한 값이 있으면 있다, 없으면 없다 출력
8. 종료

과제:
여러분의 주제를 가지고 
 - 배열 >> ArrayList 로 변경
 - 삭제기능 추가

// 사원 테이블 > 이름, 부서, 급여, 등급, 보너스 포인트(double), 총급여
1. 입력
2. 출력
3. 계산
4. 검색
5. 삭제
6. 종료

2025.04.02 (9일차)
생성자 함수
Default 생성자
 - 리턴 값이 없다.
 - 클래스와 동일한 이름으로 만든다.(권장)
public 클래스명() { }


생성자 오버로딩 (함수 오버로딩)
함수명일 같을 때
매개변수 갯수나 타입이 다르면 같은 이름을 사용할 수 있다.

오버로딩 조건이 아닌 것
 - 접근제어자
 - 리턴값

오버로딩
 - 같은 클래스 내에서 메서드 이름은 같지만, 매개변수가 다른 여러 메서드를 정의하는 것
오버라이딩
 - 부모 클래스에서 정의된 메서드를 자식 클래스에서 재정의 하는것
 > 함수명, 매개변수 갯수, 타입, 접근제어자, 리턴값, 예외처리 모두 같아야함. (접근제어자, 예외처리는 범위가 더크면 된다.)
 > 접근제어자 영역이 커져야함.

상속 시 멤버 변수, 멤버 함수는 상속되지만 생성자는 상속되지 않음.
생성자 호출을 위해 super를 사용


과제 : 
패턴 검색 만들어오기





2025.04.01 (8일차)

실행 클래스 (메인 포함된)
데이터 클래스

static
O > 코드 영역에
X > 힙 영역에


클래스 주제를 정해서 만든다
메인을 만든다
입출력 대화식 반복

멤버 변수는 직접 접근하지 않는다.
함수를 통해 접근해라. (get, set)

캡슐화의 장점
1. 멤버 변수와 멤버 함수를 하나로 묶는다.
2. 외부로부터의 접근을 막아 내부 정보를 은닉한다.


과제 : 
하나의 주제를 정해서 어제 과제의 클래스화



2025.03.31 (7일차)

가상 메모리
1. method 영역
2. stack 영역
3. hip 영역

배열의 장점
1. 변수 하나로 사용
2. 반복문 사용 용이
배열의 단점
3. 확장/축소가 안된다.

배열의 단점을 개선한 클래스 > ArrayList


과제
1. 다음은 학생 성적 입력 프로그램을 작성한다. (10명정도 입력)
1.1 구조는 배열을 이용한다. (ArrayList 가능)
1.2 학생정보는 이름, 나이, 성별, 국어, 영어, 총점, 평균, 등급별로 저장되어 있어야한다.
String[] name = new String[10];
int[] age = new int[10];
char[] gender = new char[10];
int[] kor = new int[10];
int[] eng = new int[10];
int[] total = new int[10];
double[] avr = new double[10];
String[] grade = new String[10];  A+,A, B+,B,C+,C,D+,D,F
1.3 입력은 이름, 나이, 성별, 국어 영어 만 입력한다. 총점, 평균, 등급은 계산해서 저장한다.
1.4 메뉴를 만든다.(학생입력, 학생출력, 종료, 학생계산, 
학생검색(선택) :이름  if(imsiName.equals(name[i])){  정보를 출력하면된다.}


1. 학생입력
2. 학생출력
3. 학생계산
4. 학생검색
5. 종료




2025.03.28 (6일차)

문자열과 정수,실수를 덧셈 계산하면 문자열로 변환하여 계산한다. "100"+200 => 100200
문자열과 정수,실수를 뺄셈 계산하면 계산하지 않는다.

메모리는 1번지당 1바이트

포인터 변수 4바이트인 이유 => 2^32-1 => 번지수 이기 때문에 2^30*2^2 => 2^30 = 1GB => 1GB*4 => 4GB

패턴 검색
Pattern.maches()

정규표현식
* => 0개이상
+ => 1개 이상
{2,3} => 2~3개

1. 라이브러리 함수가 있는가
2. 상수가 있는가

switch문을 쓰는 이유
if else 

실습 : 
문제 1) 별표 찍기 1~5단계 (1개 선택)
문제 2) 4단계패턴
 - 성명, 국, 영, 수 입력받아서 패턴 검색(잘못되면 다시 입력 받을 것)
 - 총점 : 국 영 수 합산
 - 평균 : 총점 / 과목수 (소숫점 2자리까지 실수값으로)
 - 등급 : A B C D F 등급으로 구한다. (switch, if~else if 2가지로 작성)
 - 출력 : 포맷에 알맞게(간지나게)
 - 조건 : 대화식 무한반복


2025.03.27 (5일차)

과제:
자바연습문제
2장
1~13
15~19

코딩
5, 7번

4단계







2025.03.26 (4일차)
do-while 사용법

참조변수의 Default값은 null

기본형 변수에는 값이 직접 저장된다.
(int, double, ...)
참조형 변수에는 객체의 번지가 저장된다.
(배열,클래스,인터페이스)

과제 : 
빛이 n일동안 이동한거리 입력받아서 출력
형변환 실습
33페이지 중간 점검

1. 8비트 124 => (    )(b) => (    )(o) => (    )(x)
2. 8비트 -24 메모리저장 되었을때 표현 (           )(b)
3. 45.125F 메모리저장 되었을때 표현 32비트 구조 (           )(b)
4. 연산자 우선 순위 표



2025.03.25 (3일차)

과제: 수업시간 완료
20, 10을입력을 받아서 사칙연산 계산하여 출력하는 프로그램
1. 상수
2. 입력받아서
3. 반복문


513L : long형 리터럴 상수

1의 보수를 쓰면 가산기를 한번더 사용하기 때문에 "2의 보수"를 사용
(속도 우위)

모든 연산은 덧셈으로 한다

뺄셈 : 뺄 숫자를 2의 보수 시켜서 덧셈
곱셈 : 왼쪽으로 비트 이동 << ? 
나눗셈 : 오른쪽으로 비트 이동 >> ?


실수는 정확한 값을 알기 어렵다.
실수를 쓰는 순간 속도는 느리다.
최대한 근사치라도 구하기 위해 float보단 double을 사용한다.


과제:

자바 연습문제 워드파일
8페이지 3번 
사용자로부터 두 개의 정수를 받아서......
4단계로 
1. 출력
2. 입력받아서 출력
3. 반복해서 입출력
4. 대화식 무한반복


진법 변환
정규식 표현방법(정수, 실수)





===============================================
2025.03.24 (2일차)

자바는 중립적인 언어로 컴파일을 하게되면 바이트코드로 만든다.



컴파일
 >
바이트코드 (중간언어)
 > 
인터프리터

JVM이 바이트코드를 한줄씩 읽어서 실행


인터프리터

API : 유용한 기능을 제공하는 라이브러리의 모임

라이브러리

배열의 문제를 개선시킨 것 : 컬렉션


String name = "";		//참조변수, 첫글자 대문자, 문자열 = 4byte
int age = 3;		//4byte
double weight = 3.14;	//8byte
boolean gender = 1;	//1byte
char bloodType = 'B';	//2byte

java => UTF-16 으로 2byte 체계


입력 받기
Scanner scan = new Scanner(System.in);

scan.nextLine();

scan.close();

nextLine(); 형변환해서 사용하는 이유
외부 장치와 속도차이가 나면 반드시 완충장치를  한다. => 버퍼


for( ; ; ){
	무한으로 돌아감
}


무한 반복
bool 변수(flag값)를 통한 대화식 무한반복

1. 출력
2. 입력받아서 출력
3. 반복해서 입출력
4. 대화식 무한반복



과제:
대화식 무한 반복
정수형 실수형 문자열 문자 boolean 까지 코드 작성



코드, 결과값
화면캡처해서


스캔 경고 왜뜨는지...?
자원 누수 경고: 코드의 마지막에서 scan.close()를 호출하고 있지만, System.in을 사용하는 경우에는 닫힌 입력 스트림을 이후에 다른 작업에서 사용하려고 하면 문제가 될 수 있습니다. 예를 들어 Scanner 객체를 닫아버리면 같은 스트림을 통해 추가 입력을 받으려 할 때 예외가 발생할 수 있습니다. 








